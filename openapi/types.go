// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApplicationScopes = "application.Scopes"
)

// Defines values for QuestionSettingsMultipleChoiceQuestionType.
const (
	QuestionSettingsMultipleChoiceQuestionTypeMultipleChoice QuestionSettingsMultipleChoiceQuestionType = "MultipleChoice"
)

// Defines values for QuestionSettingsNumberQuestionType.
const (
	QuestionSettingsNumberQuestionTypeNumber QuestionSettingsNumberQuestionType = "Number"
)

// Defines values for QuestionSettingsScaleQuestionType.
const (
	QuestionSettingsScaleQuestionTypeScale QuestionSettingsScaleQuestionType = "Scale"
)

// Defines values for QuestionSettingsSingleChoiceQuestionType.
const (
	QuestionSettingsSingleChoiceQuestionTypeSingleChoice QuestionSettingsSingleChoiceQuestionType = "SingleChoice"
)

// Defines values for QuestionSettingsTextQuestionType.
const (
	QuestionSettingsTextQuestionTypeText QuestionSettingsTextQuestionType = "Text"
)

// Defines values for QuestionSettingsTextLongQuestionType.
const (
	QuestionSettingsTextLongQuestionTypeTextLong QuestionSettingsTextLongQuestionType = "TextLong"
)

// Defines values for QuestionTypeMultipleChoiceQuestionType.
const (
	QuestionTypeMultipleChoiceQuestionTypeMultipleChoice QuestionTypeMultipleChoiceQuestionType = "MultipleChoice"
)

// Defines values for QuestionTypeNumberQuestionType.
const (
	QuestionTypeNumberQuestionTypeNumber QuestionTypeNumberQuestionType = "Number"
)

// Defines values for QuestionTypeScaleQuestionType.
const (
	QuestionTypeScaleQuestionTypeScale QuestionTypeScaleQuestionType = "Scale"
)

// Defines values for QuestionTypeSingleChoiceQuestionType.
const (
	QuestionTypeSingleChoiceQuestionTypeSingleChoice QuestionTypeSingleChoiceQuestionType = "SingleChoice"
)

// Defines values for QuestionTypeTextQuestionType.
const (
	QuestionTypeTextQuestionTypeText QuestionTypeTextQuestionType = "Text"
)

// Defines values for QuestionTypeTextLongQuestionType.
const (
	QuestionTypeTextLongQuestionTypeTextLong QuestionTypeTextLongQuestionType = "TextLong"
)

// Defines values for ResShareType.
const (
	Admins      ResShareType = "admins"
	Anyone      ResShareType = "anyone"
	Respondents ResShareType = "respondents"
)

// Defines values for ResponseBodyMultipleChoiceQuestionType.
const (
	MultipleChoice ResponseBodyMultipleChoiceQuestionType = "MultipleChoice"
)

// Defines values for ResponseBodyNumberQuestionType.
const (
	Number ResponseBodyNumberQuestionType = "Number"
)

// Defines values for ResponseBodyScaleQuestionType.
const (
	Scale ResponseBodyScaleQuestionType = "Scale"
)

// Defines values for ResponseBodySingleChoiceQuestionType.
const (
	SingleChoice ResponseBodySingleChoiceQuestionType = "SingleChoice"
)

// Defines values for ResponseBodyTextQuestionType.
const (
	Text ResponseBodyTextQuestionType = "Text"
)

// Defines values for ResponseBodyTextLongQuestionType.
const (
	TextLong ResponseBodyTextLongQuestionType = "TextLong"
)

// Defines values for ResponseSortType.
const (
	ResponseSortTypeModifiedAtASC   ResponseSortType = "modified_at"
	ResponseSortTypeModifiedAtDESC  ResponseSortType = "-modified_at"
	ResponseSortTypeSubmittedAtASC  ResponseSortType = "submitted_at"
	ResponseSortTypeSubmittedAtDESC ResponseSortType = "-submitted_at"
	ResponseSortTypeTitleASC        ResponseSortType = "title"
	ResponseSortTypeTitleDESC       ResponseSortType = "-title"
)

// Defines values for SortType.
const (
	SortTypeCreatedAtASC   SortType = "created_at"
	SortTypeCreatedAtDESC  SortType = "-created_at"
	SortTypeModifiedAtASC  SortType = "modified_at"
	SortTypeModifiedAtDESC SortType = "-modified_at"
	SortTypeTitleASC       SortType = "title"
	SortTypeTitleDESC      SortType = "-title"
)

// EditQuestionnaire defines model for EditQuestionnaire.
type EditQuestionnaire struct {
	Admin       *UsersAndGroups `json:"admin,omitempty"`
	Description string          `json:"description"`

	// IsAnonymous 匿名回答かどうか
	IsAnonymous bool `json:"is_anonymous"`

	// IsDuplicateAnswerAllowed 一人が複数回回答できるかどうか
	IsDuplicateAnswerAllowed bool `json:"is_duplicate_answer_allowed"`

	// IsPublished アンケートが公開されているかどうか
	IsPublished     bool       `json:"is_published"`
	QuestionnaireId int        `json:"questionnaire_id"`
	Questions       []Question `json:"questions"`

	// ResponseDueDateTime 回答期限。この日時を過ぎたら回答できなくなる。nullの場合は回答期限なし。
	ResponseDueDateTime *time.Time `json:"response_due_date_time,omitempty"`

	// ResponseViewableBy アンケートの結果を, 運営は見られる ("admins"), 回答済みの人は見られる ("respondents") 誰でも見られる ("anyone")
	ResponseViewableBy ResShareType    `json:"response_viewable_by"`
	Target             *UsersAndGroups `json:"target,omitempty"`
	Title              string          `json:"title"`
}

// EditQuestionnaireTargetsAndAdmins defines model for EditQuestionnaireTargetsAndAdmins.
type EditQuestionnaireTargetsAndAdmins struct {
	Admin  *UsersAndGroups `json:"admin,omitempty"`
	Target *UsersAndGroups `json:"target,omitempty"`
}

// Groups defines model for Groups.
type Groups = []string

// NewQuestion defines model for NewQuestion.
type NewQuestion struct {
	Body string `json:"body"`

	// IsRequired 回答必須かどうか
	IsRequired bool `json:"is_required"`
	union      json.RawMessage
}

// NewQuestionnaire defines model for NewQuestionnaire.
type NewQuestionnaire struct {
	Admin       UsersAndGroups `json:"admin"`
	Description string         `json:"description"`

	// IsAnonymous 匿名回答かどうか
	IsAnonymous bool `json:"is_anonymous"`

	// IsDuplicateAnswerAllowed 一人が複数回回答できるかどうか
	IsDuplicateAnswerAllowed bool `json:"is_duplicate_answer_allowed"`

	// IsPublished アンケートが公開されているかどうか
	IsPublished bool          `json:"is_published"`
	Questions   []NewQuestion `json:"questions"`

	// ResponseDueDateTime 回答期限。この日時を過ぎたら回答できなくなる。nullの場合は回答期限なし。
	ResponseDueDateTime *time.Time `json:"response_due_date_time,omitempty"`

	// ResponseViewableBy アンケートの結果を, 運営は見られる ("admins"), 回答済みの人は見られる ("respondents") 誰でも見られる ("anyone")
	ResponseViewableBy ResShareType   `json:"response_viewable_by"`
	Target             UsersAndGroups `json:"target"`
	Title              string         `json:"title"`
}

// NewResponse defines model for NewResponse.
type NewResponse struct {
	Body    []ResponseBody `json:"body"`
	IsDraft bool           `json:"is_draft"`
}

// Question defines model for Question.
type Question struct {
	Body      string    `json:"body"`
	CreatedAt time.Time `json:"created_at"`

	// IsRequired 回答必須かどうか
	IsRequired bool `json:"is_required"`

	// QuestionId 質問を追加する場合はnull。
	QuestionId      *int `json:"question_id,omitempty"`
	QuestionnaireId int  `json:"questionnaire_id"`
	union           json.RawMessage
}

// QuestionBase defines model for QuestionBase.
type QuestionBase struct {
	Body string `json:"body"`

	// IsRequired 回答必須かどうか
	IsRequired bool `json:"is_required"`
}

// QuestionSettingsByType defines model for QuestionSettingsByType.
type QuestionSettingsByType struct {
	union json.RawMessage
}

// QuestionSettingsMultipleChoice defines model for QuestionSettingsMultipleChoice.
type QuestionSettingsMultipleChoice struct {
	Options      []string                                   `json:"options"`
	QuestionType QuestionSettingsMultipleChoiceQuestionType `json:"question_type"`
}

// QuestionSettingsMultipleChoiceQuestionType defines model for QuestionSettingsMultipleChoice.QuestionType.
type QuestionSettingsMultipleChoiceQuestionType string

// QuestionSettingsNumber defines model for QuestionSettingsNumber.
type QuestionSettingsNumber struct {
	MaxValue     *int                               `json:"max_value,omitempty"`
	MinValue     *int                               `json:"min_value,omitempty"`
	QuestionType QuestionSettingsNumberQuestionType `json:"question_type"`
}

// QuestionSettingsNumberQuestionType defines model for QuestionSettingsNumber.QuestionType.
type QuestionSettingsNumberQuestionType string

// QuestionSettingsScale defines model for QuestionSettingsScale.
type QuestionSettingsScale struct {
	MaxLabel     *string                           `json:"max_label,omitempty"`
	MaxValue     int                               `json:"max_value"`
	MinLabel     *string                           `json:"min_label,omitempty"`
	MinValue     int                               `json:"min_value"`
	QuestionType QuestionSettingsScaleQuestionType `json:"question_type"`
}

// QuestionSettingsScaleQuestionType defines model for QuestionSettingsScale.QuestionType.
type QuestionSettingsScaleQuestionType string

// QuestionSettingsSingleChoice defines model for QuestionSettingsSingleChoice.
type QuestionSettingsSingleChoice struct {
	Options      []string                                 `json:"options"`
	QuestionType QuestionSettingsSingleChoiceQuestionType `json:"question_type"`
}

// QuestionSettingsSingleChoiceQuestionType defines model for QuestionSettingsSingleChoice.QuestionType.
type QuestionSettingsSingleChoiceQuestionType string

// QuestionSettingsText defines model for QuestionSettingsText.
type QuestionSettingsText struct {
	MaxLength    *int                             `json:"max_length,omitempty"`
	QuestionType QuestionSettingsTextQuestionType `json:"question_type"`
}

// QuestionSettingsTextQuestionType defines model for QuestionSettingsText.QuestionType.
type QuestionSettingsTextQuestionType string

// QuestionSettingsTextLong defines model for QuestionSettingsTextLong.
type QuestionSettingsTextLong struct {
	MaxLength    *float32                             `json:"max_length,omitempty"`
	QuestionType QuestionSettingsTextLongQuestionType `json:"question_type"`
}

// QuestionSettingsTextLongQuestionType defines model for QuestionSettingsTextLong.QuestionType.
type QuestionSettingsTextLongQuestionType string

// QuestionTypeMultipleChoice defines model for QuestionTypeMultipleChoice.
type QuestionTypeMultipleChoice struct {
	QuestionType QuestionTypeMultipleChoiceQuestionType `json:"question_type"`
}

// QuestionTypeMultipleChoiceQuestionType defines model for QuestionTypeMultipleChoice.QuestionType.
type QuestionTypeMultipleChoiceQuestionType string

// QuestionTypeNumber defines model for QuestionTypeNumber.
type QuestionTypeNumber struct {
	QuestionType QuestionTypeNumberQuestionType `json:"question_type"`
}

// QuestionTypeNumberQuestionType defines model for QuestionTypeNumber.QuestionType.
type QuestionTypeNumberQuestionType string

// QuestionTypeScale defines model for QuestionTypeScale.
type QuestionTypeScale struct {
	QuestionType QuestionTypeScaleQuestionType `json:"question_type"`
}

// QuestionTypeScaleQuestionType defines model for QuestionTypeScale.QuestionType.
type QuestionTypeScaleQuestionType string

// QuestionTypeSingleChoice defines model for QuestionTypeSingleChoice.
type QuestionTypeSingleChoice struct {
	QuestionType QuestionTypeSingleChoiceQuestionType `json:"question_type"`
}

// QuestionTypeSingleChoiceQuestionType defines model for QuestionTypeSingleChoice.QuestionType.
type QuestionTypeSingleChoiceQuestionType string

// QuestionTypeText defines model for QuestionTypeText.
type QuestionTypeText struct {
	QuestionType QuestionTypeTextQuestionType `json:"question_type"`
}

// QuestionTypeTextQuestionType defines model for QuestionTypeText.QuestionType.
type QuestionTypeTextQuestionType string

// QuestionTypeTextLong defines model for QuestionTypeTextLong.
type QuestionTypeTextLong struct {
	QuestionType QuestionTypeTextLongQuestionType `json:"question_type"`
}

// QuestionTypeTextLongQuestionType defines model for QuestionTypeTextLong.QuestionType.
type QuestionTypeTextLongQuestionType string

// QuestionnaireBase defines model for QuestionnaireBase.
type QuestionnaireBase struct {
	Description string `json:"description"`

	// IsAnonymous 匿名回答かどうか
	IsAnonymous bool `json:"is_anonymous"`

	// IsDuplicateAnswerAllowed 一人が複数回回答できるかどうか
	IsDuplicateAnswerAllowed bool `json:"is_duplicate_answer_allowed"`

	// IsPublished アンケートが公開されているかどうか
	IsPublished bool `json:"is_published"`

	// ResponseDueDateTime 回答期限。この日時を過ぎたら回答できなくなる。nullの場合は回答期限なし。
	ResponseDueDateTime *time.Time `json:"response_due_date_time,omitempty"`

	// ResponseViewableBy アンケートの結果を, 運営は見られる ("admins"), 回答済みの人は見られる ("respondents") 誰でも見られる ("anyone")
	ResponseViewableBy ResShareType `json:"response_viewable_by"`
	Title              string       `json:"title"`
}

// QuestionnaireCreatedAt defines model for QuestionnaireCreatedAt.
type QuestionnaireCreatedAt struct {
	CreatedAt time.Time `json:"created_at"`
}

// QuestionnaireDescription defines model for QuestionnaireDescription.
type QuestionnaireDescription struct {
	Description string `json:"description"`
}

// QuestionnaireDetail defines model for QuestionnaireDetail.
type QuestionnaireDetail struct {
	Admin UsersAndGroups `json:"admin"`

	// Admins 回答者の一覧。匿名回答の場合はnull。
	Admins      *Users    `json:"admins,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	Description string    `json:"description"`

	// IsAnonymous 匿名回答かどうか
	IsAnonymous bool `json:"is_anonymous"`

	// IsDuplicateAnswerAllowed 一人が複数回回答できるかどうか
	IsDuplicateAnswerAllowed bool `json:"is_duplicate_answer_allowed"`

	// IsPublished アンケートが公開されているかどうか
	IsPublished     bool       `json:"is_published"`
	ModifiedAt      time.Time  `json:"modified_at"`
	QuestionnaireId int        `json:"questionnaire_id"`
	Questions       []Question `json:"questions"`

	// Respondents 回答者の一覧。匿名回答の場合はnull。
	Respondents Users `json:"respondents"`

	// ResponseDueDateTime 回答期限。この日時を過ぎたら回答できなくなる。nullの場合は回答期限なし。
	ResponseDueDateTime *time.Time `json:"response_due_date_time,omitempty"`

	// ResponseViewableBy アンケートの結果を, 運営は見られる ("admins"), 回答済みの人は見られる ("respondents") 誰でも見られる ("anyone")
	ResponseViewableBy ResShareType   `json:"response_viewable_by"`
	Target             UsersAndGroups `json:"target"`

	// Targets 回答者の一覧。匿名回答の場合はnull。
	Targets *Users `json:"targets,omitempty"`
	Title   string `json:"title"`
}

// QuestionnaireID defines model for QuestionnaireID.
type QuestionnaireID struct {
	QuestionnaireId int `json:"questionnaire_id"`
}

// QuestionnaireInfo defines model for QuestionnaireInfo.
type QuestionnaireInfo struct {
	CreatedAt time.Time `json:"created_at"`

	// IsTargetingMe 自分がターゲットになっているかどうか
	IsTargetingMe bool      `json:"is_targeting_me"`
	ModifiedAt    time.Time `json:"modified_at"`

	// ResponseDueDateTime 回答期限。この日時を過ぎたら回答できなくなる。nullの場合は回答期限なし。
	ResponseDueDateTime *time.Time `json:"response_due_date_time,omitempty"`
	Title               string     `json:"title"`
}

// QuestionnaireIsAnonymous defines model for QuestionnaireIsAnonymous.
type QuestionnaireIsAnonymous struct {
	// IsAnonymous 匿名回答かどうか
	IsAnonymous bool `json:"is_anonymous"`
}

// QuestionnaireIsDuplicateAnswerAllowed defines model for QuestionnaireIsDuplicateAnswerAllowed.
type QuestionnaireIsDuplicateAnswerAllowed struct {
	// IsDuplicateAnswerAllowed 一人が複数回回答できるかどうか
	IsDuplicateAnswerAllowed bool `json:"is_duplicate_answer_allowed"`
}

// QuestionnaireIsPublished defines model for QuestionnaireIsPublished.
type QuestionnaireIsPublished struct {
	// IsPublished アンケートが公開されているかどうか
	IsPublished bool `json:"is_published"`
}

// QuestionnaireIsRemindEnabled defines model for QuestionnaireIsRemindEnabled.
type QuestionnaireIsRemindEnabled struct {
	// IsRemindEnabled 自分に対するリマインドが有効かどうか。ユーザーが対象者でありかつ回答していない場合、この値がtrueであればリマインドが送信される。
	IsRemindEnabled bool `json:"is_remind_enabled"`
}

// QuestionnaireIsTargetingMe defines model for QuestionnaireIsTargetingMe.
type QuestionnaireIsTargetingMe struct {
	// IsTargetingMe 自分がターゲットになっているかどうか
	IsTargetingMe bool `json:"is_targeting_me"`
}

// QuestionnaireList defines model for QuestionnaireList.
type QuestionnaireList struct {
	// PageMax 合計のページ数
	PageMax        int                    `json:"page_max"`
	Questionnaires []QuestionnaireSummary `json:"questionnaires"`
}

// QuestionnaireModifiedAt defines model for QuestionnaireModifiedAt.
type QuestionnaireModifiedAt struct {
	ModifiedAt time.Time `json:"modified_at"`
}

// QuestionnaireResponseDueDateTime defines model for QuestionnaireResponseDueDateTime.
type QuestionnaireResponseDueDateTime struct {
	// ResponseDueDateTime 回答期限。この日時を過ぎたら回答できなくなる。nullの場合は回答期限なし。
	ResponseDueDateTime *time.Time `json:"response_due_date_time,omitempty"`
}

// QuestionnaireResponseViewableBy defines model for QuestionnaireResponseViewableBy.
type QuestionnaireResponseViewableBy struct {
	// ResponseViewableBy アンケートの結果を, 運営は見られる ("admins"), 回答済みの人は見られる ("respondents") 誰でも見られる ("anyone")
	ResponseViewableBy ResShareType `json:"response_viewable_by"`
}

// QuestionnaireSummary defines model for QuestionnaireSummary.
type QuestionnaireSummary struct {
	// AllResponded すべての対象者が回答済みの場合 true を返す。それ以外は false を返す。 (対象者が存在しない場合は true を返す)
	AllResponded bool      `json:"all_responded"`
	CreatedAt    time.Time `json:"created_at"`
	Description  string    `json:"description"`

	// HasMyDraft 下書きが存在する
	HasMyDraft bool `json:"has_my_draft"`

	// HasMyResponse 回答が存在する
	HasMyResponse bool `json:"has_my_response"`

	// IsAnonymous 匿名回答かどうか
	IsAnonymous bool `json:"is_anonymous"`

	// IsDuplicateAnswerAllowed 一人が複数回回答できるかどうか
	IsDuplicateAnswerAllowed bool `json:"is_duplicate_answer_allowed"`

	// IsPublished アンケートが公開されているかどうか
	IsPublished bool `json:"is_published"`

	// IsTargetingMe 自分がターゲットになっているかどうか
	IsTargetingMe         bool       `json:"is_targeting_me"`
	ModifiedAt            time.Time  `json:"modified_at"`
	QuestionnaireId       int        `json:"questionnaire_id"`
	RespondedDateTimeByMe *time.Time `json:"responded_date_time_by_me,omitempty"`

	// ResponseDueDateTime 回答期限。この日時を過ぎたら回答できなくなる。nullの場合は回答期限なし。
	ResponseDueDateTime *time.Time `json:"response_due_date_time,omitempty"`

	// ResponseViewableBy アンケートの結果を, 運営は見られる ("admins"), 回答済みの人は見られる ("respondents") 誰でも見られる ("anyone")
	ResponseViewableBy ResShareType `json:"response_viewable_by"`
	Title              string       `json:"title"`
}

// QuestionnaireTargetsAndAdmins defines model for QuestionnaireTargetsAndAdmins.
type QuestionnaireTargetsAndAdmins struct {
	Admin  UsersAndGroups `json:"admin"`
	Target UsersAndGroups `json:"target"`
}

// QuestionnaireTitle defines model for QuestionnaireTitle.
type QuestionnaireTitle struct {
	Title string `json:"title"`
}

// ResShareType アンケートの結果を, 運営は見られる ("admins"), 回答済みの人は見られる ("respondents") 誰でも見られる ("anyone")
type ResShareType string

// Response defines model for Response.
type Response struct {
	Body            []ResponseBody `json:"body"`
	IsAnonymous     *bool          `json:"is_anonymous,omitempty"`
	IsDraft         bool           `json:"is_draft"`
	ModifiedAt      time.Time      `json:"modified_at"`
	QuestionnaireId int            `json:"questionnaire_id"`

	// Respondent traQ ID
	Respondent  *TraqId   `json:"respondent,omitempty"`
	ResponseId  int       `json:"response_id"`
	SubmittedAt time.Time `json:"submitted_at"`
}

// ResponseBody defines model for ResponseBody.
type ResponseBody struct {
	union json.RawMessage
}

// ResponseBodyBaseInteger defines model for ResponseBodyBaseInteger.
type ResponseBodyBaseInteger struct {
	Answer int `json:"answer"`
}

// ResponseBodyBaseNumber defines model for ResponseBodyBaseNumber.
type ResponseBodyBaseNumber struct {
	Answer float32 `json:"answer"`
}

// ResponseBodyBaseString defines model for ResponseBodyBaseString.
type ResponseBodyBaseString struct {
	Answer string `json:"answer"`
}

// ResponseBodyMultipleChoice defines model for ResponseBodyMultipleChoice.
type ResponseBodyMultipleChoice struct {
	Answer       []int                                  `json:"answer"`
	QuestionType ResponseBodyMultipleChoiceQuestionType `json:"question_type"`
}

// ResponseBodyMultipleChoiceQuestionType defines model for ResponseBodyMultipleChoice.QuestionType.
type ResponseBodyMultipleChoiceQuestionType string

// ResponseBodyNumber defines model for ResponseBodyNumber.
type ResponseBodyNumber struct {
	Answer       float32                        `json:"answer"`
	QuestionType ResponseBodyNumberQuestionType `json:"question_type"`
}

// ResponseBodyNumberQuestionType defines model for ResponseBodyNumber.QuestionType.
type ResponseBodyNumberQuestionType string

// ResponseBodyScale defines model for ResponseBodyScale.
type ResponseBodyScale struct {
	Answer       int                           `json:"answer"`
	QuestionType ResponseBodyScaleQuestionType `json:"question_type"`
}

// ResponseBodyScaleQuestionType defines model for ResponseBodyScale.QuestionType.
type ResponseBodyScaleQuestionType string

// ResponseBodySingleChoice defines model for ResponseBodySingleChoice.
type ResponseBodySingleChoice struct {
	Answer       int                                  `json:"answer"`
	QuestionType ResponseBodySingleChoiceQuestionType `json:"question_type"`
}

// ResponseBodySingleChoiceQuestionType defines model for ResponseBodySingleChoice.QuestionType.
type ResponseBodySingleChoiceQuestionType string

// ResponseBodyText defines model for ResponseBodyText.
type ResponseBodyText struct {
	Answer       string                       `json:"answer"`
	QuestionType ResponseBodyTextQuestionType `json:"question_type"`
}

// ResponseBodyTextQuestionType defines model for ResponseBodyText.QuestionType.
type ResponseBodyTextQuestionType string

// ResponseBodyTextLong defines model for ResponseBodyTextLong.
type ResponseBodyTextLong struct {
	Answer       string                           `json:"answer"`
	QuestionType ResponseBodyTextLongQuestionType `json:"question_type"`
}

// ResponseBodyTextLongQuestionType defines model for ResponseBodyTextLong.QuestionType.
type ResponseBodyTextLongQuestionType string

// ResponseSortType response用のsortの種類
type ResponseSortType string

// ResponseWithQuestionnaireInfoItem defines model for ResponseWithQuestionnaireInfoItem.
type ResponseWithQuestionnaireInfoItem struct {
	Body              []ResponseBody     `json:"body"`
	IsAnonymous       *bool              `json:"is_anonymous,omitempty"`
	IsDraft           bool               `json:"is_draft"`
	ModifiedAt        time.Time          `json:"modified_at"`
	QuestionnaireId   int                `json:"questionnaire_id"`
	QuestionnaireInfo *QuestionnaireInfo `json:"questionnaire_info,omitempty"`

	// Respondent traQ ID
	Respondent  *TraqId   `json:"respondent,omitempty"`
	ResponseId  int       `json:"response_id"`
	SubmittedAt time.Time `json:"submitted_at"`
}

// Responses defines model for Responses.
type Responses = []Response

// ResponsesWithQuestionnaireInfo defines model for ResponsesWithQuestionnaireInfo.
type ResponsesWithQuestionnaireInfo = []ResponseWithQuestionnaireInfoItem

// SortType question、questionnaire用のソートの種類
type SortType string

// TraqId traQ ID
type TraqId = string

// Users 回答者の一覧。匿名回答の場合はnull。
type Users = []TraqId

// UsersAndGroups defines model for UsersAndGroups.
type UsersAndGroups struct {
	Groups Groups `json:"groups"`

	// Users 回答者の一覧。匿名回答の場合はnull。
	Users Users `json:"users"`
}

// OnlyAdministratedByMeInQuery defines model for onlyAdministratedByMeInQuery.
type OnlyAdministratedByMeInQuery = bool

// OnlyMyResponseInQuery defines model for onlyMyResponseInQuery.
type OnlyMyResponseInQuery = bool

// OnlyTargetingMeInQuery defines model for onlyTargetingMeInQuery.
type OnlyTargetingMeInQuery = bool

// PageInQuery defines model for pageInQuery.
type PageInQuery = int

// QuestionnaireIDInPath defines model for questionnaireIDInPath.
type QuestionnaireIDInPath = int

// ResponseIDInPath defines model for responseIDInPath.
type ResponseIDInPath = int

// ResponseSortInQuery response用のsortの種類
type ResponseSortInQuery = ResponseSortType

// SearchInQuery defines model for searchInQuery.
type SearchInQuery = string

// SortInQuery question、questionnaire用のソートの種類
type SortInQuery = SortType

// GetQuestionnairesParams defines parameters for GetQuestionnaires.
type GetQuestionnairesParams struct {
	// Sort 並び順 (作成日時が新しい "created_at", 作成日時が古い "-created_at", タイトルの昇順 "title", タイトルの降順 "-title", 更新日時が新しい "modified_at", 更新日時が古い "-modified_at" )
	Sort *SortInQuery `form:"sort,omitempty" json:"sort,omitempty"`

	// Search タイトルの検索
	Search *SearchInQuery `form:"search,omitempty" json:"search,omitempty"`

	// Page 何ページ目か (未定義の場合は1ページ目)
	Page *PageInQuery `form:"page,omitempty" json:"page,omitempty"`

	// OnlyTargetingMe 自分がターゲットになっているもののみ取得 (true), ターゲットになっているものも含めてすべて取得 (false)。デフォルトはfalse。
	OnlyTargetingMe *OnlyTargetingMeInQuery `form:"onlyTargetingMe,omitempty" json:"onlyTargetingMe,omitempty"`

	// OnlyAdministratedByMe 自分が管理者になっていないもののみ取得 (true), 管理者になっているものも含めてすべて取得 (false)。デフォルトはfalse。
	OnlyAdministratedByMe *OnlyAdministratedByMeInQuery `form:"onlyAdministratedByMe,omitempty" json:"onlyAdministratedByMe,omitempty"`
}

// GetQuestionnaireResponsesParams defines parameters for GetQuestionnaireResponses.
type GetQuestionnaireResponsesParams struct {
	// Sort 並び順 (作成日時が新しい "submitted_at", 作成日時が古い "-submitted_at", タイトルの昇順 "title", タイトルの降順 "-title", 更新日時が新しい "modified_at", 更新日時が古い "-modified_at" )
	Sort *ResponseSortInQuery `form:"sort,omitempty" json:"sort,omitempty"`

	// OnlyMyResponse 自分の回答のみ取得 (true), 自分の回答以外も含めてすべて取得 (false)。デフォルトはfalse。
	OnlyMyResponse *OnlyMyResponseInQuery `form:"onlyMyResponse,omitempty" json:"onlyMyResponse,omitempty"`
}

// GetMyResponsesParams defines parameters for GetMyResponses.
type GetMyResponsesParams struct {
	// Sort 並び順 (作成日時が新しい "submitted_at", 作成日時が古い "-submitted_at", タイトルの昇順 "title", タイトルの降順 "-title", 更新日時が新しい "modified_at", 更新日時が古い "-modified_at" )
	Sort *ResponseSortInQuery `form:"sort,omitempty" json:"sort,omitempty"`
}

// PostQuestionnaireJSONRequestBody defines body for PostQuestionnaire for application/json ContentType.
type PostQuestionnaireJSONRequestBody = NewQuestionnaire

// EditQuestionnaireJSONRequestBody defines body for EditQuestionnaire for application/json ContentType.
type EditQuestionnaireJSONRequestBody = EditQuestionnaire

// EditQuestionnaireMyRemindStatusJSONRequestBody defines body for EditQuestionnaireMyRemindStatus for application/json ContentType.
type EditQuestionnaireMyRemindStatusJSONRequestBody = QuestionnaireIsRemindEnabled

// PostQuestionnaireResponseJSONRequestBody defines body for PostQuestionnaireResponse for application/json ContentType.
type PostQuestionnaireResponseJSONRequestBody = NewResponse

// EditResponseJSONRequestBody defines body for EditResponse for application/json ContentType.
type EditResponseJSONRequestBody = Response

// AsQuestionSettingsText returns the union data inside the NewQuestion as a QuestionSettingsText
func (t NewQuestion) AsQuestionSettingsText() (QuestionSettingsText, error) {
	var body QuestionSettingsText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsText overwrites any union data inside the NewQuestion as the provided QuestionSettingsText
func (t *NewQuestion) FromQuestionSettingsText(v QuestionSettingsText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsText performs a merge with any union data inside the NewQuestion, using the provided QuestionSettingsText
func (t *NewQuestion) MergeQuestionSettingsText(v QuestionSettingsText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsTextLong returns the union data inside the NewQuestion as a QuestionSettingsTextLong
func (t NewQuestion) AsQuestionSettingsTextLong() (QuestionSettingsTextLong, error) {
	var body QuestionSettingsTextLong
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsTextLong overwrites any union data inside the NewQuestion as the provided QuestionSettingsTextLong
func (t *NewQuestion) FromQuestionSettingsTextLong(v QuestionSettingsTextLong) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsTextLong performs a merge with any union data inside the NewQuestion, using the provided QuestionSettingsTextLong
func (t *NewQuestion) MergeQuestionSettingsTextLong(v QuestionSettingsTextLong) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsNumber returns the union data inside the NewQuestion as a QuestionSettingsNumber
func (t NewQuestion) AsQuestionSettingsNumber() (QuestionSettingsNumber, error) {
	var body QuestionSettingsNumber
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsNumber overwrites any union data inside the NewQuestion as the provided QuestionSettingsNumber
func (t *NewQuestion) FromQuestionSettingsNumber(v QuestionSettingsNumber) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsNumber performs a merge with any union data inside the NewQuestion, using the provided QuestionSettingsNumber
func (t *NewQuestion) MergeQuestionSettingsNumber(v QuestionSettingsNumber) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsSingleChoice returns the union data inside the NewQuestion as a QuestionSettingsSingleChoice
func (t NewQuestion) AsQuestionSettingsSingleChoice() (QuestionSettingsSingleChoice, error) {
	var body QuestionSettingsSingleChoice
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsSingleChoice overwrites any union data inside the NewQuestion as the provided QuestionSettingsSingleChoice
func (t *NewQuestion) FromQuestionSettingsSingleChoice(v QuestionSettingsSingleChoice) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsSingleChoice performs a merge with any union data inside the NewQuestion, using the provided QuestionSettingsSingleChoice
func (t *NewQuestion) MergeQuestionSettingsSingleChoice(v QuestionSettingsSingleChoice) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsMultipleChoice returns the union data inside the NewQuestion as a QuestionSettingsMultipleChoice
func (t NewQuestion) AsQuestionSettingsMultipleChoice() (QuestionSettingsMultipleChoice, error) {
	var body QuestionSettingsMultipleChoice
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsMultipleChoice overwrites any union data inside the NewQuestion as the provided QuestionSettingsMultipleChoice
func (t *NewQuestion) FromQuestionSettingsMultipleChoice(v QuestionSettingsMultipleChoice) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsMultipleChoice performs a merge with any union data inside the NewQuestion, using the provided QuestionSettingsMultipleChoice
func (t *NewQuestion) MergeQuestionSettingsMultipleChoice(v QuestionSettingsMultipleChoice) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsScale returns the union data inside the NewQuestion as a QuestionSettingsScale
func (t NewQuestion) AsQuestionSettingsScale() (QuestionSettingsScale, error) {
	var body QuestionSettingsScale
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsScale overwrites any union data inside the NewQuestion as the provided QuestionSettingsScale
func (t *NewQuestion) FromQuestionSettingsScale(v QuestionSettingsScale) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsScale performs a merge with any union data inside the NewQuestion, using the provided QuestionSettingsScale
func (t *NewQuestion) MergeQuestionSettingsScale(v QuestionSettingsScale) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewQuestion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["body"], err = json.Marshal(t.Body)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'body': %w", err)
	}

	object["is_required"], err = json.Marshal(t.IsRequired)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'is_required': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *NewQuestion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["body"]; found {
		err = json.Unmarshal(raw, &t.Body)
		if err != nil {
			return fmt.Errorf("error reading 'body': %w", err)
		}
	}

	if raw, found := object["is_required"]; found {
		err = json.Unmarshal(raw, &t.IsRequired)
		if err != nil {
			return fmt.Errorf("error reading 'is_required': %w", err)
		}
	}

	return err
}

// AsQuestionSettingsText returns the union data inside the Question as a QuestionSettingsText
func (t Question) AsQuestionSettingsText() (QuestionSettingsText, error) {
	var body QuestionSettingsText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsText overwrites any union data inside the Question as the provided QuestionSettingsText
func (t *Question) FromQuestionSettingsText(v QuestionSettingsText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsText performs a merge with any union data inside the Question, using the provided QuestionSettingsText
func (t *Question) MergeQuestionSettingsText(v QuestionSettingsText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsTextLong returns the union data inside the Question as a QuestionSettingsTextLong
func (t Question) AsQuestionSettingsTextLong() (QuestionSettingsTextLong, error) {
	var body QuestionSettingsTextLong
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsTextLong overwrites any union data inside the Question as the provided QuestionSettingsTextLong
func (t *Question) FromQuestionSettingsTextLong(v QuestionSettingsTextLong) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsTextLong performs a merge with any union data inside the Question, using the provided QuestionSettingsTextLong
func (t *Question) MergeQuestionSettingsTextLong(v QuestionSettingsTextLong) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsNumber returns the union data inside the Question as a QuestionSettingsNumber
func (t Question) AsQuestionSettingsNumber() (QuestionSettingsNumber, error) {
	var body QuestionSettingsNumber
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsNumber overwrites any union data inside the Question as the provided QuestionSettingsNumber
func (t *Question) FromQuestionSettingsNumber(v QuestionSettingsNumber) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsNumber performs a merge with any union data inside the Question, using the provided QuestionSettingsNumber
func (t *Question) MergeQuestionSettingsNumber(v QuestionSettingsNumber) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsSingleChoice returns the union data inside the Question as a QuestionSettingsSingleChoice
func (t Question) AsQuestionSettingsSingleChoice() (QuestionSettingsSingleChoice, error) {
	var body QuestionSettingsSingleChoice
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsSingleChoice overwrites any union data inside the Question as the provided QuestionSettingsSingleChoice
func (t *Question) FromQuestionSettingsSingleChoice(v QuestionSettingsSingleChoice) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsSingleChoice performs a merge with any union data inside the Question, using the provided QuestionSettingsSingleChoice
func (t *Question) MergeQuestionSettingsSingleChoice(v QuestionSettingsSingleChoice) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsMultipleChoice returns the union data inside the Question as a QuestionSettingsMultipleChoice
func (t Question) AsQuestionSettingsMultipleChoice() (QuestionSettingsMultipleChoice, error) {
	var body QuestionSettingsMultipleChoice
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsMultipleChoice overwrites any union data inside the Question as the provided QuestionSettingsMultipleChoice
func (t *Question) FromQuestionSettingsMultipleChoice(v QuestionSettingsMultipleChoice) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsMultipleChoice performs a merge with any union data inside the Question, using the provided QuestionSettingsMultipleChoice
func (t *Question) MergeQuestionSettingsMultipleChoice(v QuestionSettingsMultipleChoice) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsScale returns the union data inside the Question as a QuestionSettingsScale
func (t Question) AsQuestionSettingsScale() (QuestionSettingsScale, error) {
	var body QuestionSettingsScale
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsScale overwrites any union data inside the Question as the provided QuestionSettingsScale
func (t *Question) FromQuestionSettingsScale(v QuestionSettingsScale) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsScale performs a merge with any union data inside the Question, using the provided QuestionSettingsScale
func (t *Question) MergeQuestionSettingsScale(v QuestionSettingsScale) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Question) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["body"], err = json.Marshal(t.Body)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'body': %w", err)
	}

	object["created_at"], err = json.Marshal(t.CreatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
	}

	object["is_required"], err = json.Marshal(t.IsRequired)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'is_required': %w", err)
	}

	if t.QuestionId != nil {
		object["question_id"], err = json.Marshal(t.QuestionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'question_id': %w", err)
		}
	}

	object["questionnaire_id"], err = json.Marshal(t.QuestionnaireId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'questionnaire_id': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Question) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["body"]; found {
		err = json.Unmarshal(raw, &t.Body)
		if err != nil {
			return fmt.Errorf("error reading 'body': %w", err)
		}
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &t.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
	}

	if raw, found := object["is_required"]; found {
		err = json.Unmarshal(raw, &t.IsRequired)
		if err != nil {
			return fmt.Errorf("error reading 'is_required': %w", err)
		}
	}

	if raw, found := object["question_id"]; found {
		err = json.Unmarshal(raw, &t.QuestionId)
		if err != nil {
			return fmt.Errorf("error reading 'question_id': %w", err)
		}
	}

	if raw, found := object["questionnaire_id"]; found {
		err = json.Unmarshal(raw, &t.QuestionnaireId)
		if err != nil {
			return fmt.Errorf("error reading 'questionnaire_id': %w", err)
		}
	}

	return err
}

// AsQuestionSettingsText returns the union data inside the QuestionSettingsByType as a QuestionSettingsText
func (t QuestionSettingsByType) AsQuestionSettingsText() (QuestionSettingsText, error) {
	var body QuestionSettingsText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsText overwrites any union data inside the QuestionSettingsByType as the provided QuestionSettingsText
func (t *QuestionSettingsByType) FromQuestionSettingsText(v QuestionSettingsText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsText performs a merge with any union data inside the QuestionSettingsByType, using the provided QuestionSettingsText
func (t *QuestionSettingsByType) MergeQuestionSettingsText(v QuestionSettingsText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsTextLong returns the union data inside the QuestionSettingsByType as a QuestionSettingsTextLong
func (t QuestionSettingsByType) AsQuestionSettingsTextLong() (QuestionSettingsTextLong, error) {
	var body QuestionSettingsTextLong
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsTextLong overwrites any union data inside the QuestionSettingsByType as the provided QuestionSettingsTextLong
func (t *QuestionSettingsByType) FromQuestionSettingsTextLong(v QuestionSettingsTextLong) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsTextLong performs a merge with any union data inside the QuestionSettingsByType, using the provided QuestionSettingsTextLong
func (t *QuestionSettingsByType) MergeQuestionSettingsTextLong(v QuestionSettingsTextLong) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsNumber returns the union data inside the QuestionSettingsByType as a QuestionSettingsNumber
func (t QuestionSettingsByType) AsQuestionSettingsNumber() (QuestionSettingsNumber, error) {
	var body QuestionSettingsNumber
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsNumber overwrites any union data inside the QuestionSettingsByType as the provided QuestionSettingsNumber
func (t *QuestionSettingsByType) FromQuestionSettingsNumber(v QuestionSettingsNumber) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsNumber performs a merge with any union data inside the QuestionSettingsByType, using the provided QuestionSettingsNumber
func (t *QuestionSettingsByType) MergeQuestionSettingsNumber(v QuestionSettingsNumber) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsSingleChoice returns the union data inside the QuestionSettingsByType as a QuestionSettingsSingleChoice
func (t QuestionSettingsByType) AsQuestionSettingsSingleChoice() (QuestionSettingsSingleChoice, error) {
	var body QuestionSettingsSingleChoice
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsSingleChoice overwrites any union data inside the QuestionSettingsByType as the provided QuestionSettingsSingleChoice
func (t *QuestionSettingsByType) FromQuestionSettingsSingleChoice(v QuestionSettingsSingleChoice) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsSingleChoice performs a merge with any union data inside the QuestionSettingsByType, using the provided QuestionSettingsSingleChoice
func (t *QuestionSettingsByType) MergeQuestionSettingsSingleChoice(v QuestionSettingsSingleChoice) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsMultipleChoice returns the union data inside the QuestionSettingsByType as a QuestionSettingsMultipleChoice
func (t QuestionSettingsByType) AsQuestionSettingsMultipleChoice() (QuestionSettingsMultipleChoice, error) {
	var body QuestionSettingsMultipleChoice
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsMultipleChoice overwrites any union data inside the QuestionSettingsByType as the provided QuestionSettingsMultipleChoice
func (t *QuestionSettingsByType) FromQuestionSettingsMultipleChoice(v QuestionSettingsMultipleChoice) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsMultipleChoice performs a merge with any union data inside the QuestionSettingsByType, using the provided QuestionSettingsMultipleChoice
func (t *QuestionSettingsByType) MergeQuestionSettingsMultipleChoice(v QuestionSettingsMultipleChoice) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsQuestionSettingsScale returns the union data inside the QuestionSettingsByType as a QuestionSettingsScale
func (t QuestionSettingsByType) AsQuestionSettingsScale() (QuestionSettingsScale, error) {
	var body QuestionSettingsScale
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuestionSettingsScale overwrites any union data inside the QuestionSettingsByType as the provided QuestionSettingsScale
func (t *QuestionSettingsByType) FromQuestionSettingsScale(v QuestionSettingsScale) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuestionSettingsScale performs a merge with any union data inside the QuestionSettingsByType, using the provided QuestionSettingsScale
func (t *QuestionSettingsByType) MergeQuestionSettingsScale(v QuestionSettingsScale) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t QuestionSettingsByType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *QuestionSettingsByType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsResponseBodyText returns the union data inside the ResponseBody as a ResponseBodyText
func (t ResponseBody) AsResponseBodyText() (ResponseBodyText, error) {
	var body ResponseBodyText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseBodyText overwrites any union data inside the ResponseBody as the provided ResponseBodyText
func (t *ResponseBody) FromResponseBodyText(v ResponseBodyText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseBodyText performs a merge with any union data inside the ResponseBody, using the provided ResponseBodyText
func (t *ResponseBody) MergeResponseBodyText(v ResponseBodyText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseBodyTextLong returns the union data inside the ResponseBody as a ResponseBodyTextLong
func (t ResponseBody) AsResponseBodyTextLong() (ResponseBodyTextLong, error) {
	var body ResponseBodyTextLong
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseBodyTextLong overwrites any union data inside the ResponseBody as the provided ResponseBodyTextLong
func (t *ResponseBody) FromResponseBodyTextLong(v ResponseBodyTextLong) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseBodyTextLong performs a merge with any union data inside the ResponseBody, using the provided ResponseBodyTextLong
func (t *ResponseBody) MergeResponseBodyTextLong(v ResponseBodyTextLong) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseBodyNumber returns the union data inside the ResponseBody as a ResponseBodyNumber
func (t ResponseBody) AsResponseBodyNumber() (ResponseBodyNumber, error) {
	var body ResponseBodyNumber
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseBodyNumber overwrites any union data inside the ResponseBody as the provided ResponseBodyNumber
func (t *ResponseBody) FromResponseBodyNumber(v ResponseBodyNumber) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseBodyNumber performs a merge with any union data inside the ResponseBody, using the provided ResponseBodyNumber
func (t *ResponseBody) MergeResponseBodyNumber(v ResponseBodyNumber) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseBodySingleChoice returns the union data inside the ResponseBody as a ResponseBodySingleChoice
func (t ResponseBody) AsResponseBodySingleChoice() (ResponseBodySingleChoice, error) {
	var body ResponseBodySingleChoice
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseBodySingleChoice overwrites any union data inside the ResponseBody as the provided ResponseBodySingleChoice
func (t *ResponseBody) FromResponseBodySingleChoice(v ResponseBodySingleChoice) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseBodySingleChoice performs a merge with any union data inside the ResponseBody, using the provided ResponseBodySingleChoice
func (t *ResponseBody) MergeResponseBodySingleChoice(v ResponseBodySingleChoice) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseBodyMultipleChoice returns the union data inside the ResponseBody as a ResponseBodyMultipleChoice
func (t ResponseBody) AsResponseBodyMultipleChoice() (ResponseBodyMultipleChoice, error) {
	var body ResponseBodyMultipleChoice
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseBodyMultipleChoice overwrites any union data inside the ResponseBody as the provided ResponseBodyMultipleChoice
func (t *ResponseBody) FromResponseBodyMultipleChoice(v ResponseBodyMultipleChoice) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseBodyMultipleChoice performs a merge with any union data inside the ResponseBody, using the provided ResponseBodyMultipleChoice
func (t *ResponseBody) MergeResponseBodyMultipleChoice(v ResponseBodyMultipleChoice) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseBodyScale returns the union data inside the ResponseBody as a ResponseBodyScale
func (t ResponseBody) AsResponseBodyScale() (ResponseBodyScale, error) {
	var body ResponseBodyScale
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseBodyScale overwrites any union data inside the ResponseBody as the provided ResponseBodyScale
func (t *ResponseBody) FromResponseBodyScale(v ResponseBodyScale) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseBodyScale performs a merge with any union data inside the ResponseBody, using the provided ResponseBodyScale
func (t *ResponseBody) MergeResponseBodyScale(v ResponseBodyScale) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResponseBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResponseBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
